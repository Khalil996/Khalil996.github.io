
---
title: 重生之我在下班时间刷leetcode（9）
date: 2025-06-26 21:00:00
---

# LeetCode 题解：不大于 K 的最长二进制子序列

题目链接：[LeetCode - Longest Binary Subsequence Less Than or Equal to K](https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/description/?envType=daily-question&envId=2025-06-26)

---

## 🧠 题目描述简要

给定一个二进制字符串 `s`（由 `'0'` 和 `'1'` 构成）以及一个正整数 `k`，请返回 `s` 中长度最长的 **子序列**（不要求连续），使其转换为整数后小于等于 `k`。

---

## 🚀 解题思路

我们需要选择字符串 `s` 中一些字符，组成一个新的 **子序列**，要求该子序列按二进制解释的值 `<= k`，并且长度尽可能长。

### 关键点：

1. **子序列**允许跳过字符，但顺序要保持。
2. 要满足二进制值不大于 `k`。
3. 想让长度最长 → 应尽可能多选择字符，尤其是 `'0'`。

---

## ✅ 解法分析（贪心 + 位数限制）

### 思路：

1. 首先确定 `k` 的二进制长度为 `m`，也就是说任意超过 `m` 位的子序列，其值一定大于 `k`。
2. 所以最多只能选出 **后缀中最多 `m` 位** 的字符来尝试构成合法二进制数。
3. 对于 `s` 最后 `m` 位，我们判断该二进制数是否 `<= k`。
   - 若超过 `k`，我们舍弃最高位，即将 `ans = m - 1`。
   - 否则，`ans = m`。
4. **关键优化**：可以任意添加前导 `'0'`，不会影响值（仍小于等于 `k`），所以我们统计前面 `n - m` 个字符中 `'0'` 的个数，加到 `ans` 上。

---

## 💻 Go 代码实现

```go
func longestSubsequence(s string, k int) int {
    n, m := len(s), bits.Len(uint(k)) // m 是 k 的二进制位数
    if n < m {
        return n // 全部保留也不会超出
    }
    ans := m
    sufVal, _ := strconv.ParseInt(s[n-m:], 2, 0)
    if int(sufVal) > k {
        ans-- // 最后的 m 位构成的数大于 k，去掉最高位
    }
    return ans + strings.Count(s[:n-m], "0") // 前面可以尽量加 0
}
```

---

## 🔍 示例讲解

```text
s = "1001010", k = 5

k = 5 -> 二进制为 "101"，m = 3
从 s 最后 3 位截取子串 "010" → 十进制为 2 <= 5 ✔️

ans = 3（这三位都可以保留）
然后前面部分是 "1001"，其中有两个 '0'，也可以加入

最终答案为 3 + 2 = 5
```

---

## ✅ 总结

| 步骤 | 说明 |
|------|------|
| 位数限制 | 任何大于 `bits.Len(k)` 位的子序列一定大于 k |
| 允许添加前导 0 | `'0'` 不影响二进制大小，尽量多选 |
| 后缀判断 | 最多保留 `m` 位，判断其二进制值是否超出 |
| 时间复杂度 | O(n)，非常高效 |

---

## 📌 补充知识

- `bits.Len(uint(k))`：Go 标准库函数，用于获取 `k` 的二进制位数。
- `strconv.ParseInt`：将字符串当作二进制解释成整数。
- `strings.Count(s, "0")`：快速统计字符串中 `'0'` 的个数。

---
