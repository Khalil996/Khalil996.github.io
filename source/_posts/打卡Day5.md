---
title: 算法每日打卡
---
# 每日算法打卡

## 题目：

### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

**提示：**

- `1 <= prices.length <= 105`

- `0 <= prices[i] <= 105`

  

### 思路：

这题的思路就是DP，这题允许我们完成俩笔交易，那么我们就会有5种状态：

- 未进行过任何操作；
- 只进行过一次买操作；（设为buy1）
- 进行了一次买操作和一次卖操作，即完成了一笔交易；（设为sell1）
- 在完成了一笔交易的前提下，进行了第二次买操作；（设为buy2）
- 完成了全部两笔交易。（设为sell2）



首先，我们先看buy1，我们可以把buy1看成在没有任何操作下把prices[i]买入，那么buy1的转换方式就是

​                                           *buy1=max{buy1,-prices[i]}*

对于sell1而言，我们可以看成在进行一次买的操作的前提下把prices[i]卖出去，那么转换方式就是：

​                                         *sell1=max{sell1,prices[i]+buy1}*

同理，对于buy2而言，我们可以看成我们在卖出第一次交易后立马买进了相应的价格，那么转换方式就是：

​										*buy2=max{buy2,sell-price[i]}*

sell2也是这样，

​										*sell2=max{sell2,buy2+prices[i]}*

在这里要注意边界情况，就是在同一天买入卖出这一操作是不影响最后答案的，因为你在进行这一操作的时候，收入是为0

同时在决定最终答案的时候我们应该在0，sell1，sell2中去寻找最大值，同时我们在允许边界情况下，且维护最大值，那么最终答案就为sell2，这里可以附一张我做题时列的表格:![img](file:///D:\QQDate\2649475267\Image\C2C\ED19D9F953406D3BFA1C0EACF4BC7B3C.jpg)

### 代码：

```golang
func maxProfit(prices []int) int {
    buy1,sell1:=-prices[0],0
    buy2,sell2:=-prices[0],0
  for i:=1;i<len(prices);i++{
     buy1=max(buy1,-prices[i])
     sell1=max(sell1,buy1+prices[i])
     buy2=max(buy2,sell1-prices[i])
     sell2=max(sell2,buy2+prices[i])
  }
  return sell2
}

func max(a, b int) int { if a < b { return b }; return a }

```

